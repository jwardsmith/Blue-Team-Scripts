# Malware Persistence Locations

### AutoStart Location

#### HOW TO HUNT: autorunsc.exe

*Also known as AutoStart Extension Points (ASEPs). By far, the most popular ASEPs on the planet are the "run" Registry keys. Excellent starting place to look for malicious activity on a system. Only a fraction of possible locations are below.*

**Executed when a user logs on:**
- NTUSER.DAT\Software\Microsoft\Windows\CurrentVersion\Run
- NTUSER.DAT\Software\Microsoft\Windows\CurrentVersion\Runonce
- SOFTWARE\Microsoft\Windows\CurrentVersion\Runonce
- SOFTWARE\Microsoft\Windows\CurrentVersion\policies\Explorer\Run
- SOFTWARE\Microsoft\Windows\CurrentVersion\Run

**Executed at boot:**
- SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit

**Startup Folder (shortcut files) (does not require local admin) - Executed when a user logs on:**
- %AppData%\Roaming\Microsoft\Windows\Start Menu\Programs\Startup

### Service Creation/Replacement/Recovery

*Designed to run applications in the background without user interaction. Many services are required at system boot. Services can be standalone executables or loaded as DLLs. Service configurations, as well as device driver configurations, are stored in the Registry under HKLM\SYSTEM\CurrentControlSet\Services. The keys here provide the paramters for each service, including the service name, display name, path to the service's executable image file, the start value, required privileges, dependencies, and more. Each service has a start type value configured to start at boot, by manual intervention, or on trigger events such as obtaining an IP address or hardware device connections. Start values of 0x02 (Automatic) and 0x00 (Boot start of a device driver) can provide persistence for malicious code.*

**New Service Creation:**
- Start value of 0x02 will start automatically.

**Service Replacement:**
- Modify and autostart a service to load new binary. Finds a current service that is disabled or unneeded and replaces the existing binary with a malicious one.

**Service Failure Recovery:**
- Load a malicious binary when a specific service crashes. Check service properties -> Recovery -> First failure = Run a Program.

### Scheduled Tasks

*Provide an extremely granular means to create persistence. The command at.exe is deprecated but still used, while schtasks.exe is the upgraded version of at.exe. Task information is stored in C:\Windows\Tasks or C:\Windows\System32\Tasks. Tasks can be set for specific Windows events such as when a specific userf logs on. Both at.exe and schtasks.exe can schedule tasks on remote systems. Most forensics artifacts for these remote tasks will be present on the systems they were executed on, not the originating system.*

**at.exe:**
- Deprecated, but still present in WinXP and Win7+.
- Use recorded in at*.job files and Schdlgu.txt (WinXP).

**schtasks.exe:**
- Activity logged in Task Scheduler and Security logs.

### DLL Hijacking

*These attack legitimate and legacy features of the Windows operating system.*

**DLL Search Order Hijacking:**
- Place malicious file ahead of DLL in search order.
- When an executable runs in Windows, it is not required to hardcode the location of any DLLs. Instead a specific search order is often used to find the required DLL, starting with the local directory the executable is run from and eventually ending up in a folder like C:\Windows\System32 where most standard DLLs exist. The only real exception is for DLLs present in the KnownDLLs Registry key that does effectively hardcode a small number of specific system DLL locations.
- If an adversary can find an executable that is not located in C:\Windows\System32 and loads a DLL not present in the KnownDLLs Registry key, they can place a malicious DLL in the same folder as the target executable and trump the search order, ensuring their malicious code is loaded whenever the application starts.
- The search order below is common to modern systems with the option SafeDllSearchMode enabled (enabled by default).
  1. DLLs already loaded in memory
  2. Side-by-Side Components
  3. KnownDLLs list
  4. Directory from which application is loaded
  5. C:\Windows\System32
  6. C:\Windows\System
  7. C:\Windows
  8. Current Directory
  9. System %PATH%

**Phantom DLL Hijacking:**
- Find DLLs that applications attempt to load, but either don't exist or can be replaced.
- Some very old DLLs are still attempted to be loaded by applications even when they are completely unnecessary. Some no longer even exist on modern Windows.
- Attackers can provide a malicious DLL with the same name in the search path, and code will be executed.

**DLL Side-Loading:**
- WinSxS mechanism provides a new version of a legit DLL.
- Uses the Windows side-by-side (SxS) DLL loading mechanism to introduce an "updated" version of a  DLL. SxS functionality is a legitimate feature of Windows and is used by many applications to prevent problems that can arise due to updated and duplicate versions of DLLs.
- SxS gives the ability to load updated DLLs, but has few validty checks for new DLLs and thus the loading mechanism can be abused due to missing DLLs, use of relative paths, and other shortcuts not taken into account by the application developer.
- This attack is often used to circumvent AV protections and provides an opportunity for a known good, even digitally signed, executable to be used as a persistence mechanism.

**Relative Path DLL Hijacking:**
- Copy susceptible.exe and corresponding bad.dll to location of choice.
- Could also be called "bring your own executable".
- An alternative to search order hijacking attempts. An attacker can just copy a susceptible executable from one of the protected folders to any writeable location, then add the malicious DLL to be loaded in the same folder, and they now have an easy way to get the malicious code executed.

### WMI Event Consumers

*WMI allows triggers (filter) to be set that when satisfied will run scripts or executables (consumer). Administrative privileges are necessary. WMI consumers run with SYSTEM privileges. Filters can be based on time (every 20 seconds), service start, user authentication, file creation etc... The three steps are often written inside a managed object format (MOF) file that is used to register new classes into the WMI repository. To be even more stealthy, Set-WmiInstance or CreateInstance can also be used.*

**Event Filter = Trigger condition:**
- Get-WmiObject -Namespace root\Subscription -Class __Filter
- Get-WmiObject -Namespace root\Default -Class __Filter

**Event Consumer = Script or executable to run:**
- Get-WmiObject -Namespace root\Subscription -Class __Consumer
- Get-WmiObject -Namespace root\Default -Class __Consumer
- Interesting search terms:
  1. .exe
  2. .vbs
  3. .ps1
  4. .dll
  5. .eval
  6. ActiveXObject
  7. powershell
  8. CommandLineTemplate
  9. ScriptText
- Common false positives:
  1. SCM Event Log Consumer
  2. BVTFilter
  3. TSlogonEvents.vbs
  4. TSLogonFilter
  5. RAevent.vbs
  6. RMAssistEventFilter
  7. KernCap.vbs
  8. NTEventLogConsumer
  9. WSCEAA.exe (Dell)
- Types of consumers
  1. ActiveScriptEventConsumer = Execute a predefined script: Visual Basic or Jscript
  2. CommandLineEventConsumer = Launch an arbitrary process
  3. LogFileEventConsumer = Write to a text log file
  4. NTEventLogEventConsumer = Log a message to Event Log
  5. SMTPEventConsumer = Email a message via SMTP
  6. Custom = Requires custom COM object

**Binding = Tie together Filter + Consumer:**
- Get-WmiObject -Namespace root\Subscription -Class __FilterToConsumerBinding
- Get-WmiObject -Namespace root\Default -Class __FilterToConsumerBinding

### More Advanced - Local Group Policy, MS Office Add-In, or BIOS Flashing
